科目名: プログラミング実習III
課題: B3
番号: 37022443
氏名: 黒川良太
作成: 10/15

----------------------------------------

[課題3-1]
 pointerに関して貼る楽器の授業よりも理解が深まった。
int 型の変数 a, b と double 型の変数 x, y を宣言し, それぞれの番地を表示するプログラム pointer1.c を作成せよ. 実行してどのような数値が番地として表示されたか (どのような数の増え方になっているか) をレポートに記せ.



結果　

各変数の番地はメモリ上で連続している傾向があり、その順序は変数の宣言順に従うことが多くなっていると考えられる。



----------------------------------------

[課題3-2]
番地とポインタの関係について理解が深まった。
課題 (3-1) の pointer1.c と同様に int 型の変数 a, b と double 型の変数 x, y を宣言して番地を表示し, その番地を用いて変数 a, b, x, y の値を書き換え, a, b, x, y の値を表示するプログラム pointer2.c を作成せよ.

結果
macのため、自宅で実行ができないため、割愛させていただきます。

----------------------------------------

[課題3-3]
ポインタの理解が深まった。前問と同じく番地についてより正確に考えるようになった。
次のようなプログラム pointer3.c を作成せよ.

課題 (3-1) の pointer1.c と同様に int 型の変数 a, b と double 型の変数 x, y を宣言する.
int 型ポインタ変数と double 型ポインタ変数を宣言する.
変数 a, b, x, y の番地を表示する.
ポインタ変数を用いて, b の値に 4 を足し, x の値を 2 倍する.
double 型変数 (x と y) の番地を入力し, その番地に格納されている値を表示する (番地 0 が入力されるまで繰り返す).


結果

aの番地 = 0x16b5ddd8c
bの番地 = 0x16b5ddd88
xの番地 = 0x16b5ddd78
yの番地 = 0x16b5ddd70
番地を入力 : 0x16b5ddd78
0x16b5ddd78 番地の内容は 8.000000
番地を入力 : 0x16b5ddd70
0x16b5ddd70 番地の内容は 6.000000


----------------------------------------

[課題3-4]
ポインター変数と実際の数値、番地についてもう少し知りたいと感じた。

int 型変数 x と y, および int 型へのポインタ変数 q, r を受け取り, x を y で割った商を q 番地の変数に, 剰余を r 番地の変数に格納して返す関数 divrem を作成せよ.

下記のプログラムの空欄を埋め, 完成したプログラムを divrem.c として提出せよ.


結果

x / y = 3 ... 1
----------------------------------------

[課題3-5]
ポインタや番地を用いた計算いについての理解が深まった。
double 型の値 a と b, double 型へのポインタ p_a, p_m を受け取り, a と b の相加平均を p_a 番地に, 相乗平均を p_m 番地に格納する関数 void ave(double a, double b, double *p_a, double *p_m) を作成せよ.

関数 ave は ave6.c というファイルに格納せよ. 関数 ave のプロトタイプ宣言を格納した下記の ave6.h をインクルードせよ. 下記の ave6main.c と ave6.c をリンクして実行し, 動作を確認せよ.



結果

1.500 1.414
3.500 3.464
5.500 5.477


----------------------------------------

[課題3-6]
qeqという同じアクションに関して多くの作り方があるのがプログラミングの面白さだと感じた。
課題 (2-4) で作成した qeq2.c を次のように書き換え, qeq3.c を作成せよ.

関数を int qeq(double a, double b, double c, double *x1, double *x2) とする. 関数 qeq の中で解を出力するのではなく, 解の個数を返り値として返し, 解を *x1 と *x2 にセットするようにせよ. 解が 1 つの場合は, *x1 にその解をセットせよ. 解が 2 つの場合は, 小さい方を *x1 に, もう一方を *x2 にセットするようにせよ.
ヘッダファイル次の qeq3.h をインクルードするようにせよ. 次の qeq3main.c とリンクして動作を確認せよ. プログラムは qeq3.c のみ提出せよ.
結果

-2.00000 -1.00000
-1.00000

-4.13746 -0.36254
-0.74568 2.14568
1.00000
0.37417 3.05440
0.81386 3.68614


----------------------------------------

[課題3-7]
構造体に関しての理解が少し深まったと思う。modelに近しいと感じた。

課題 (2-3) と同様の構造体型

typedef struct {
  double x;   /* x座標 */
  double y;   /* y座標 */
} point_t;

が定義されているとする. 下記の 2 つの関数を作成し, ファイル dist5.c に格納せよ.
int point_scan(point_t *p)
p の指す point_t 型変数のメンバー x と y に標準入力から実数値を読み込む.
標準入力が EOF の場合には EOF を, そうでない場合は 1 を返す.
double dist(point_t *p1, point_t *p2)
2点 *p1 と *p2 の間の距離を返す.

結果

1.4142
5.8310
3.1396

----------------------------------------

[課題3-8]
配列なども組み合わさり、ポインタの理解が深まった。
xのアドレスの番号「i」が増えるごとに4づつ増える。また、配列名のアドレスは先頭の要素のアドレスと一致する。


教科書 p. 382 を参考に, sizeof 演算子を用いて配列 x[ ] の要素数を求めて k に代入し, それを出力せよ.
x[0], x[1], …, x[k-1] のアドレスを出力せよ (printf の書式指定には %p を用いよ). アドレスがいくつづつ増えているかレポートに記せ.
x の値 (アドレス) を表示せよ (printf の書式指定には %p を用いよ). 2 で表示したアドレスのいずれと一致するかレポートに記せ.
x+0, x+1, …, x+k-1 の値 (アドレス) を表示せよ. 2 で表示したアドレスのいずれと一致するかレポートに記せ.
アドレス x+0, x+1, …, x+k-1 に格納されているデータの値を表示せよ. x[0], x[1], …, x[k-1] のいずれの値と一致するかレポートに記せ.
int 型を指すポインタ変数 p を宣言し, p に x[2] のアドレスを代入せよ. このとき，p+2 の値 (アドレス) と p[2] の値を表示せよ. なぜそのような値になるのかを考察し, 結果をレポートに記せ．


結果

k = 5
番地：0x16d7add90
値：0
番地：0x16d7add94
値：10
番地：0x16d7add98
値：20
番地：0x16d7add9c
値：30
番地：0x16d7adda0
値：40

0x16d7add94
0x16d7add98
0x16d7add9c
0x16d7adda0
0x16d7adda4

0x16d7adda0
40
----------------------------------------

[課題3-9]
ポインタの理解が深まった。配列や標準入力などについても理解が深まった。

下記の 2 つの関数を作成し, ファイル ave_max.c に格納せよ.

int array_scan(int a[ ])
int 型配列 a[ ] に標準入力からデータを読み込み (EOF で終了判定する; 最大のデータ数は MAX 個とする), その 要素数を返す.
void array_ave_max(int n, int a[ ], double *ave, int *max)
配列 a[ ] とサイズ n を受け取り, a[0]〜a[n-1] の平均値と最大値をそれぞれ *ave, *max に格納する.
ave_max.c からは次の ave_max.h (および標準ヘッダ stdio.h) をインクルードすること.




結果
5 4 3 2 1 9 8 7 6 10のとき　→ 5.500 10
-20 -14 -6 -10のとき　→ -12.500 -6
----------------------------------------

[課題3-10]
初めよりもポインタの理解が深まった。乱数などとのポインタの組み合わせについて理解が深まった。

3個のサイコロを n 回振ったときに出た目の和がどのような分布になっているか, を調べるプログラム dice3.c を作る. このプログラムに必要になる下記の 2 つの関数を作成し, ファイル dice3sub.c に格納せよ.

void dice_throw(int d[ ], int n)
1〜6 の整数の一様乱数を n 個発生し, d[0]〜d[n-1] に格納する.
void dice3_distr(int n, int d1[ ], int d2[ ], int d3[ ], int c[ ])
d1[0]〜d1[n-1] は 1 個目のサイコロを n 回振ったときに出た目を記録したものであり, d2[0]〜d2[n-1] は 2 個目のサイコロを n 回振ったときに出た目を記録したものであり, d3[0]〜d3[n-1] は 3 個目のサイコロを n 回振ったときに出た目を記録したものとする. この関数は, n, d1[ ], d2[ ], d3[ ] を受け取り, d1[i] と d2[i] と d3[i] の和 s が出現した回数を c[s] にカウントする.
dice3sub.c からは次の dice3sub.h (および必要な標準ヘッダ) をインクルードすること.



結果

サイコロを振る回数 n = 3
 3:      0
 4:      0
 5:      0
 6:      1
 7:      0
 8:      0
 9:      0
10:      1
11:      0
12:      0
13:      0
14:      0
15:      1
16:      0
17:      0
18:      0



[課題 R3 の感想]
これまで苦手意識のあったポインタについての理解が深まって良かったと思う。思っている以上にポインタはプログラミングにおいて重要なものであると感じた。また、ポインタを用いたプログラミングは、ポインタを用いないプログラミングよりも、より効率的にプログラミングを行うことができると感じた。今後もポインタを用いたプログラミングを行っていきたいと思う。