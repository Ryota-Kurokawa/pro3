科目名: プログラミング実習III
課題: B6
番号: 37022443
氏名: 黒川良太
作成: 11/12

----------------------------------------

[課題1]
listの中に要素を追記していくことができるようにする

教科書に書いていることをうつしているようなものなので完全に理解はできていないので、コードリーディングをしたいと思う。


----------------------------------------

[課題2]
リストの中で同じものを探してその該当するものの正負を反転させる
コードを考えるのに時間がかかった。

結果
input = 1
[ 1 ]
input = 2
[ 2 1 ]
input = 2
[ -2 1 ]

----------------------------------------

[課題3]
リストの中で同じものを探してその該当するものがある場合、その要素はスキップする。
難易度としては全問のfindを用いるのでそこまで高いものではなかった。

結果
input = 1
[ 1 ]
input = 2
[ 2 1 ]
input = 3
[ 3 2 1 ]
input = 3
[ 3 2 1 ]
input = 4
[ 4 3 2 1 ]
input = 5
[ 5 4 3 2 1 ]
input = 6
[ 6 5 4 3 2 1 ]
input = 6
[ 6 5 4 3 2 1 ]
input = 6
[ 6 5 4 3 2 1 ]
input = 6
[ 6 5 4 3 2 1 ]
input = 5
[ 6 5 4 3 2 1 ]
input = 4
[ 6 5 4 3 2 1 ]
input = 4
[ 6 5 4 3 2 1 ]
----------------------------------------

[課題4]
下記の処理を行い, (1)(2)(3) それぞれの処理に要する計算時間を表示するプログラム list4time.c を作成せよ.

(0) 標準入力から正整数 n を入力する.

(1) 乱数を n 個発生させ, それを list_insert_uniq で順次リストに挿入する.

(2) (1)と同じ乱数を n 個発生させ, list_find でそのデータをリスト中に検索する.

(3) (1)と異なる乱数を n 個発生させ, list_find でそのデータをリスト中に検索する.

いろいろな n (例えば n=5000, 10000, 15000, 20000, 25000, … 等) に対して計測を行い, データ１個あたりに必要な平均計算時間が n の増加に対してどのような割合で増加するか調べよ. その理由について考察せよ.

なお, 「処理に要する計算時間」は次のコードシーケンスにより計測できる. clock() 関数を用いるためには <time.h> をインクルードすること.

clock_t clk_start, clk_end;
  …
clk_start = clock();

<<時間を計測したい処理>>

clk_end = clock();
printf("cpu = %g [sec]\n", (double) (clk_end-clk_start)/CLOCKS_PER_SEC);

また, 乱数の発生は, 下記 myrand.c の myrand_init() と myrand() を呼び出すことにより行え (list4time.c, list.c, myrand.c をリンクして実行せよ).
最初に myrand_init() を呼び出すと, 以後 myrand() は呼び出す度に異なる整数 (乱数) を返す. n 個の乱数を発生させ, これを (1) に用いよ.
次に, 再度 myrand_init() を呼び出すと, myrand() は (1) と同じ乱数を発生する. n 個の乱数を発生させ, これを (2) に用いよ.
その後, myrand_init() を呼び出さないで myrand() を呼び出すと, (1)(2) とは異なる乱数系列が得られる. これを (3) の乱数として用いよ.

結果
おおよそ処理にかかる時間は比例の関係になっていることがわかった。

----------------------------------------

[課題5]
list.c 中の関数 list_insert_delete_dup を完成させ, 下記の list5test.c とリンクして動作確認せよ.

list_node_t* list_insert_delete_dup(list_node_t *head_p, int val) は, list_insert と同様, 値 val を持つ節点をリストの先頭に挿入しする. ただし, 既に同じ値を持つ節点がリスト中にあるときには, リストの先頭への挿入を行わず, さらに, 既にあった同じ値を持つ節点を削除する. この関数が返す値は, 挿入した節点がある場合にはその節点へのポインタであり, 挿入しなかった場合にはNULLを返す.

list5test.c は, 標準入力から次々に整数値を入力し, その数がリスト中になければリストの先頭に挿入し, もしリスト中にあればそれを削除する. 動作例を次に示す.


結果

思っているよりもこの問題は難しかった。アルゴリズムに関して理解を深めたい。

input = 1
[ 1 ]
input = 2
[ 2 1 ]
input = 3
[ 3 2 1 ]
input = 4
[ 4 3 2 1 ]
input = 5
[ 5 4 3 2 1 ]
input = 3
[ 5 4 2 1 ]
input = 2
[ 5 4 1 ]
input = 
5
[ 4 1 ]
input = 6
[ 6 4 1 ]
input = 5
[ 5 6 4 1 ]
input = 4
[ 5 6 1 ]

----------------------------------------

[課題9]
下に, tree.c, tree.h, tree9test.c を示す. tree.c は二分木の処理を行う関数群の原型, tree.h はそのヘッダファイルである. tree9test.c は, 次の動作例のように, 標準入力から次々に整数を読み込んで二分木に挿入し, 各時点での二分木の内容を表示するプログラムである. ただし, 既に二分木中に同じ値がある場合には, その値の挿入は行わない. また, 表示はデータの昇順に行う.




結果
input = 1
[ 1 ]
input = 2
[ 1 2 ]
input = 3
[ 1 2 3 ]
input = 4
[ 1 2 3 4 ]
input = 5
[ 1 2 3 4 5 ]
input = 3
[ 1 2 3 4 5 ]
input = 7
[ 1 2 3 4 5 7 ]
input = 8
[ 1 2 3 4 5 7 8 ]
input = 9
[ 1 2 3 4 5 7 8 9 ]
input = 5
[ 1 2 3 4 5 7 8 9 ]
input = 6
[ 1 2 3 4 5 6 7 8 9 ]
input = 12
[ 1 2 3 4 5 6 7 8 9 12 ]
input = 456
[ 1 2 3 4 5 6 7 8 9 12 456 ]
input = 34
[ 1 2 3 4 5 6 7 8 9 12 34 456 ]
input = 65
[ 1 2 3 4 5 6 7 8 9 12 34 65 456 ]



----------------------------------------

[課題 R の感想]
アルゴリズムに関して考えさせられる課題だった。もう少し復習をしたいと思う。