科目名: プログラミング実習III
課題: B2
番号: 37022443
氏名: 黒川良太
作成: 10/7

----------------------------------------

[課題1]
double 型の配列 a とその サイズ n, および整数 k (0≤k<n) が与えられたときに, 次の処理を行う関数 void swapmin(int n, double *a, int k) を作成せよ.

a[k]〜a[n-1] の中の最小値を a[i] とするとき, a[k] と a[i] の値を交換する.
関数は swapmin.c に格納し, 下記の swapmin_test.c とリンクして動作確認せよ.

swapmin_test.c は, 配列 a にデータを入力した後, k を入力して swapmin(n, a, k) を実行しては配列 a の内容を出力する, という動作を繰り返す (プログラムを読んで理解せよ).

自分で適切な入力を与えて, swapmin の動作が正しいことを確認せよ.

(1) n = 5,   a = 5, 4, 3, 2, 1,   k = 0 を入力 →   a = 1, 4, 3, 2, 5 となることを確認せよ.

(2) n = 5,   a = 5, 4, 3, 1, 2   k = 1 を入力 →   a = 5, 1, 3, 4, 2 となることを確認せよ.

(3) n = 5,   a = 6, 2, 4, 9, 8   に対して, k = 0, 1, 2, 3 を続けて入力すると a が昇順にソートされることを確認せよ. (下線はソート済みであることを表わす.)

k = 0 を入力 →   a = 2, 6, 4, 9, 8
k = 1 を入力 →   a = 2, 4, 6, 9, 8
k = 2 を入力 →   a = 2, 4, 6, 9, 8
k = 3 を入力 →   a = 2, 4, 6, 8, 9


結果
k = 1
swapmin(n, a, 1)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 2
swapmin(n, a, 2)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 3
swapmin(n, a, 3)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    8.00000
[4]    9.00000



----------------------------------------

[課題2]
課題 (7-1) の swapmin の動作を k=0〜n-2 について行えば, a[0]〜a[n-1] を昇順にソートできる. この考え方に基づくソーティングのアルゴリズムを「単純選択法」と言う. 単純選択法により a[0]〜a[n-1] のソートを行う関数 void sort(int n, double *a) を作成し, selection_sort.c に格納せよ.


結果
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 0.0 1.1 3.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 0.0 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 1.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 1.1
 -0.1 -0.1 -0.1 -0.1
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6



----------------------------------------

[課題3]
double 型の配列 a とその サイズ n, および整数 k (1≤k<n) が与えられたときに, 次の処理を行う関数 void insert(int n, double *a, int k) を作成せよ.

a[k] と a[k-1] を比較する. a[k]≥a[k-1] なら終了. a[k]<a[k-1] なら a[k] と a[k-1] の値を交換し, 処理を続ける.
a[k-1] と a[k-2] を比較する. a[k-1]≥a[k-2] なら終了. a[k-1]<a[k-2] なら a[k-1] と a[k-2] の値を交換し, 処理を続ける.
a[k-2] と a[k-3] を比較する. a[k-2]≥a[k-3] なら終了. a[k-2]<a[k-3] なら a[k-2] と a[k-3] の値を交換し, 処理を続ける.
…
a[1] と a[0] を比較する. a[1]≥a[0] なら終了. a[1]<a[0] なら a[1] と a[0] の値を交換する (ここまで来れば終了).
a[0]〜a[k-1] が既にソートされていると, この処理により a[k] は a[0]〜a[k-1] の間の適切な位置に挿入され, その結果 a[0]〜a[k] がソートされることになる.



結果
n = 5
[0] : 6
[1] : 2
[2] : 4
[3] : 9
[4] : 8
[0]    6.00000
[1]    2.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 1
insert(n, a, 1)
[0]    2.00000
[1]    6.00000
[2]    4.00000
[3]    9.00000
[4]    8.00000
k = 2
insert(n, a, 2)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 3
insert(n, a, 3)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    9.00000
[4]    8.00000
k = 4
insert(n, a, 4)
[0]    2.00000
[1]    4.00000
[2]    6.00000
[3]    8.00000
[4]    9.00000

----------------------------------------

[課題]
結果


----------------------------------------

[課題]

結果



----------------------------------------

[課題]

結果


----------------------------------------

[課題]

結果

----------------------------------------

[課題]




結果
----------------------------------------

[課題]




結果
----------------------------------------

[課題]




結果





[課題 R の感想]
