科目名: プログラミング実習III
課題: B2
番号: 37022443
氏名: 黒川良太
作成: 10/7

----------------------------------------

[課題 2.1]

dist.c を改善して新しいdist2.c を作成した.元々あったものの改変のため、そこまで苦労はしなかった.
    double 型の値 a, b, c (ただし a≠0 とする) を受け取って, ２次方程式 ax2+bx+c=0 の解を標準出力に出力する関数 void qeq(double a, double b, double c) を作成せよ. 解は小数点以下 5 桁で, 1 行に出力せよ. 解が 2 個ある場合には, スペース区切りで小さい順に出力すること. 解がない場合は, 改行のみ出力せよ. なお, 改行の出力は qeq 関数の中で行うこと (main の中で改行を出力しないこと)

    この関数を用いることにより, 次の動作を繰り返し行うプログラム qeq.c を作成せよ.

    実数 a, b, c を標準入力から入力し, ２次方程式 ax2+bx+c=0 の全ての解を標準出力に出力する.
    ただし, a=0 の場合には繰り返しを終了する.
    下記の qeq-in.txt の入力に対して期待値 qeq-exp.txt が出力されることを確認せよ.

結果　
1.4142
5.8310
3.1396


----------------------------------------

[課題 2.2]

二次方程式の解に関するプログラムを作成した。思っている以上に条件が多かったので苦戦したがそこまで時間はかからなかった。

    double 型の値 a, b, c (ただし a≠0 とする) を受け取って, ２次方程式 ax2+bx+c=0 の解を標準出力に出力する関数 void qeq(double a, double b, double c) を作成せよ. 解は小数点以下 5 桁で, 1 行に出力せよ. 解が 2 個ある場合には, スペース区切りで小さい順に出力すること. 解がない場合は, 改行のみ出力せよ. なお, 改行の出力は qeq 関数の中で行うこと (main の中で改行を出力しないこと)

    この関数を用いることにより, 次の動作を繰り返し行うプログラム qeq.c を作成せよ.

    実数 a, b, c を標準入力から入力し, ２次方程式 ax2+bx+c=0 の全ての解を標準出力に出力する.
    ただし, a=0 の場合には繰り返しを終了する.
    下記の qeq-in.txt の入力に対して期待値 qeq-exp.txt が出力されることを確認せよ.

結果
-2.00000 -1.00000
-1.00000

-4.13746 -0.36254
-0.74568 2.14568
1.00000
0.37417 3.05440
0.81386 3.68614

----------------------------------------

[課題 2.3]
分割コンパイルを用いてdist関数を実行した。分割コンパイルの方法が分からず苦戦したが、調べて実行することができた。
    課題 (2-1) で作成したプログラム dist2.c を, 次のファイルに分割し, 分割コンパイルを行え.

    関数 main のみを記述した dist3main.c
    関数 dist のみを記述した dist3.c
    関数 dist のプロトタイプ宣言を記述した dist3.h
    コンパイルして実行し, 課題 (1-4) と同じ dist-in.txt に対して dist-exp.txt が出力されることを確認せよ. プログラムは dist3.c のみ提出せよ.




結果
1.4142
5.8310
3.1396


----------------------------------------

[課題 2.4]
分割コンパイルについての練習だった。今後、細分化に意識したいと思う。
    課題 (2-2) で作成したプログラム qeq.c を, 次のファイルに分割し, 分割コンパイルを行え.

    関数 main のみを記述した qeq2main.c
    関数 qeq のみを記述した qeq2.c
    関数 qeq のプロトタイプ宣言を記述した qeq2.h


結果
-2.00000 -1.00000
-1.00000

-4.13746 -0.36254
-0.74568 2.14568
1.00000
0.37417 3.05440
0.81386 3.68614


----------------------------------------

[課題 2.5]
今回の課題で一番難しかった。結構な時間がかかったがやはりいつもと同様、日本語の理解が難しいと感じた。また条件分岐が複雑ではあった。
    f(x) = ax2 + bx + c に対し, 区間 [x1, x2] における f(x) = 0 の解を, 下記の「二分法」により求めて返す関数

    double bisection(double x1, double x2, double a, double b, double c, double eps)
    を作成せよ. episilon は計算の許容誤差を決めるパラメータである. ただし, a≠0 であり, f(x1) と f(x2) の符号は異なるものとする.

    【二分法】
    関数 f(x) が区間 [x1,x2] で連続であり, f(x1) と f(x2) の符号が異なるとすると, [x1,x2] に f(x)=0 の解が一つは存在する. xmid を x1 と x2 の中間の値とする. f(x1) と f(xmid) の符号が異なれば解は [x1, xmid] に, f(xmid) と f(x2) の符号が異なれば解は [xmid, x2] にある. このように, 区間の分割を繰り返すことにより解を求めるのが二分法である.
    例えば, f(x) = x2-2 として, f(x)=0 の解 (正解は√2) を求めることを考える.
    区間 [x1,x2] = [0, 5] とする.

結果
1.41400000
1.41400000
1.41400000
1.41421887
-1.41424359
1.41418750
1.41421318
7.99999976
3.58113837



----------------------------------------

[課題 2.6]
構造体に関してで、これについてはhashやプロパティ、モデルなどの概念と結びつけて理解したいと思う。
    次のような構造体型を用いて, 下記の指示に従ってプログラム body.c を作成せよ.

    #define NM_LEN 31

    typedef struct {
    char name[NM_LEN+1];  /* 名前 */
    double stature;       /* 身長 [cm] */
    double weight;        /* 重量 [kg] */
    double bmi;           /* BMI値 */
    } body_index_t;

    body_index_t 型の変数 x を受け取って, その名前, 身長, 体重, BMI (double 型の数値は全て小数点以下1桁) を次のような形式で出力する関数 void body_index_print(body_index_t x) を作成せよ.
    name: Taro
    stature: 175.4cm
    weight: 65.3kg
    BMI: 21.2

    body_index_t 型の変数 x を受け取って, BMI 値を返す関数 double bmi(body_index_t x) を作成せよ. BMI の定義は下記の通りである.
    BMI = 体重 [kg] / (身長 [m])2
    身長の単位が m であることに注意せよ. 参考までに, 標準的な BMI は 21.0 程度とされる.
    上記の関数を用いて, 次の動作を繰り返すプログラムを作成せよ.
    ある人間の名前, 身長, 体重を標準入力から body_index_t 型変数 p に読み込む. ただし, 名前が "q" の場合には繰り返しを終了する.
    関数 bmi を使って計算した BMI を p.bmi に代入する.
    関数 body_index_print を使って p の情報を出力する.

結果
name: Taro
stature: 175.4
weight: 65.3
BMI: 21.2
name: Hanako
stature: 157.3
weight: 48.8
BMI: 19.7


----------------------------------------

[課題 2.7]
構造体についての練習だった。構造体の使い方は分かったが、まだまだ理解が浅いと感じた。もう少し自分でも調べてみたい。
    課題 (2-3) の dist3.c を次のように書き換えて, dist4.c を作成せよ.

    点を 2 つの double 型変数ではなく, 次のように宣言された point_t 型を用いて表わすようにし, 関数 double dist(double x1, double y1, double x2, double y2) を, double dist(point_t p1, point_t p2) に書き換えよ.
    typedef struct {
    double x;   /* x座標 */
    double y;   /* y座標 */
    } point_t;

    構造体型 point_t の宣言は, 下記のように dist4.h 内に記述せよ. dist4.c から dist4.h をインクルードするようにせよ.
    dist4.h
    typedef struct {
    double x;   /* x座標 */
    double y;   /* y座標 */
    } point_t;

    double dist(point_t p1, point_t p2);

    次の dist4main.c とリンクして実行し, dist-in.txt に対して dist-exp.txt が出力されることを確認せよ.
    dist4main.c
    #include <stdio.h>
    #include "dist4.h"

    #define REPEAT 3

    int main(void)
    {
    point_t p1, p2;
    int r;
    for (r=0; r<REPEAT; r++) {
        fprintf(stderr, "p1 と p2 の座標 (それぞれ x と y) をスペース区切りで : ");
        scanf("%lf %lf", &p1.x, &p1.y);
        fprintf(stderr, "p2 の座標 (x と y): ");
        scanf("%lf %lf", &p2.x, &p2.y);
        printf("%0.4f\n", dist(p1,p2));
    }
    return 0;
    }



結果
1.4142
5.8310
3.1396

----------------------------------------

[課題 2.8]
乱数に関する基礎的な課題であった。乱数を使うことは今の開発においてあまり使ったことがないので、今後使う機会があれば積極的に使っていきたい。

2つの整数 a, b を受け取り, 区間 [a,b] の整数値の乱数を発生させて返す関数 irand(int a, int b) を作成せよ. この関数を用いて次の操作を行うプログラム irand.c を作成せよ.

3つの整数 a, b, n を入力し, irand(a,b) を n 回呼び出して生成された乱数を出力する.
a から b までの数について, その数が何回生成されたかを数えて出力する.
表示形式は下記の実行例に倣え.
次の動作確認を行うこと.
a=11, b=20, n=10000 を入力して, 11〜20 がおよそ 1000 づつ生成されていることを確認せよ.
a=7, b=8, n=10 を入力して, 7 と 8 の生成数の合計が 10 になっていることを確認せよ.
xyz01234@DGLP00 ~/B2
$ ./a
a, b, n を入力: 3 8 50
4 4 8 5 7 5 3 5 8 4 3 8 3 5 6 8 4 4 7 7 6 4 6 8 7 6 6 3 5 4 4 
5 5 4 5 6 4 4 6 6 4 5 4 3 8 8 5 4 3 4
3: 6
4: 15
5: 10
6: 8
7: 4
8: 7

xyz01234@DGLP00 ~/B2
$



結果

ここに10000の数字を入力するわけにもいかないので割愛します。



[課題 R1 の感想]

R2では、構造体についての課題が多かった。構造体については、今まであまり使ったことがなかったので、今後使う機会があれば積極的に使っていきたいと思う。また、今回の課題で一番難しかったのは、二分法についての課題だった。二分法については、今まで全く知らなかったので、調べて理解するのに時間がかかった。しかし、調べて理解することができたので、今後の課題にも活かしていきたいと思う。
また、乱数において上限と下限を決める正規表現のようなものについては完璧に理解できていないので調べてみたい。
